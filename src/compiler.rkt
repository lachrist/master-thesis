#lang racket

(struct idiom (type expr locus))

(define (locus:make-empty) null)
(define (locus:union locus1 .. locusN) null)
(define (locus:add locus type1 type2) null)
(define (locus:close! locus marker) null)
(define (locus:project locus ass) null)

(define (type:type-of constant) null)
(define (type:make-poly marker monotype) null)
(define (type:poly? type) null)
(define (type:sub polytype) null)
(define (type:make-abs arg-type res-type) null)
(define (type:abs-arg type) null)
(define (type:abs-res type) null)
(define (type:make-marker!) null)
(define (type:make-var! marker) null)

(define (dico:add ass id type) null)
(define (dico:lookup ass id) null)




(define (tagged-list? expr tag)
  (and (list? expr) (not (null? expr)) (eq? (car expr))))

(define (compile expr ass marker)
  (cond ((tagged-list? expr 'lambda) (compile-abs expr ass marker))
        ((tagged-list? expr 'let)    (compile-let expr ass marker))
        ((tagged-list? expr 'if)     (compile-if expr ass marker))
        ((symbol? expr)              (compile-id expr ass marker))
        ((not (list? expr))          (compile-const expr ass marker))
        (else                        (compile-app expr ass marker))))

;; CONST => CONST
(define (compile-const expr ass marker)
  (idiom (type:type-of expr)
         expr
         (locus:make-empty)))

;; SYMBOL => SYMBOL
;;        => (<polytype> <monotype> SYMBOL)
(define (compile-id expr ass marker)
  (define (compile-poly-id polytype)
    (let ((monotype (type:sub polytype marker)))
      (idiom monotype
             (list 'sub polytype monotype expr)
             (locus:make-empty))))
  (define (compile-mono-id monotype)
    (idiom monotype
           expr
           (locus:make-empty)))
  (let ((bind (dico:lookup ass expr)))
    (if (type:poly? bind)
        (compile-poly-id bind)
        (compile-mono-id bind))))

;; (lambda <param> <body>) => (lambda <param> <compiled-body>)
(define (compile-abs expr ass marker)
  (let* ((param ((car (cdr expr))))
         (body ((car (cdr (cdr expr)))))
         (arg-var (type:make-var! marker))
         (ext-ass (dico:add ass param arg-var))
         (body-idiom (compile body ext-ass marker)))
    (idiom (type:make-abs arg-var (idiom-type body-idiom))
           (list 'lambda param (idiom-expr body-idiom))
           (idiom-locus body-idiom))))

;; (<proc> <arg>) => (<compiled-proc> <compiled-arg>)
(define (compile-app expr ass marker)
  (let* ((abs (car (expr)))
         (arg (car (cdr expr)))
         (abs-idiom (compile abs ass marker))
         (arg-idiom (compile arg ass marker)))
    (idiom (type:abs-res (idiom-type abs-idiom))
           (list (idiom-expr abs-idiom) (idiom-expr arg-idiom))
           (locus:add (locus:union (idiom-locus abs-idiom) (idiom-locus arg-idiom))
                      (type:abs-arg (idiom-type abs-idiom)) (idiom-type arg-idiom)))))

;; (if <pred> <then> <else>) => (delay <type-var> <marker> <ass> <compiled-pred> <then> <else>)
(define (compile-if expr ass marker)
  (let* ((pred (car (cdr expr)))
         (then (car (cdr (cdr expr))))
         (else (car (cdr (cdr expr))))
         (pred-idiom (compile pred ass))
         (var (type:make-var! marker)))
    (idiom var
           (list 'delay var marker ass (idiom-expr pred-idiom) then else)
           (idiom-locus pred-idiom))))

;; (let <param> <bind> <body>) => (let <param> <compiled-bind> <compiled-body>)
(define (compile-let expr ass marker)
  (define (compile-let-abs param bind body)
    (let* ((bind-marker (type:make-marker!))
           (bind-var (type:make-var! bind-marker))
           (mono-ext-ass (dico:add ass param bind-var))
           (bind-idiom (compile bind mono-ext-ass bind-marker))
           (bind-monotype (idiom-type bind-idiom))
           (bind-polytype (type:make-poly marker bind-monotype))
           (bind-locus (locus:add (idiom-locus bind-idiom) bind-var bind-monotype))
           (poly-ext-ass (dico:add ass param bind-polytype))
           (body-idiom (compile body poly-ext-ass marker)))
      (locus:close! bind-locus marker)
      (idiom (idiom-type body-idiom)
             (list 'let param (idiom-expr bind-idiom) (idiom-expr body-idiom))
             (locus:union bind-locus (idiom-locus body-idiom)))))
  (define (compile-let-rest param bind body)
    (let* ((bind-idiom (compile bind ass))
           (ext-ass (dico:add ass param (idiom-type bind-idiom)))
           (body-idiom (compile body ext-ass)))
      (idiom (idiom-type body-idiom)
             (list 'let param (idiom-expr bind-idiom) (idiom-expr body-idiom))
             (locus:union (idiom-locus bind-idiom) (idiom-locus body-idiom)))))
  (let ((param (car (cdr expr)))
        (bind  (car (cdr (cdr expr))))
        (body  (car (cdr (cdr (cdr expr))))))
    (if (tagged-list? bind 'lambda)
        (compile-let-abs param bind body)
        (compile-let-rest param bind body))))

(define (finalize tree locus)
  (cond ((tagged-list? tree 'delay) (finalize-delay tree locus))
        ((list? tree) (map (lambda (tree) (finalize tree locus)) tree))
        (else tree)))

;; (delay <var> <marker> <ass> <compiled-pred> <then> <else>)
;; => (if <compiled-pred> <then-locus> <compiled-then> <else-locus> <compiled-else>)
(define (finalize-delay delay locus)
  (let* ((var           (car (cdr delay)))
         (marker        (car (cdr (cdr delay))))
         (ass           (car (cdr (cdr (cdr delay)))))
         (compiled-pred (car (cdr (cdr (cdr (cdr delay))))))
         (then          (car (cdr (cdr (cdr (cdr (cdr delay)))))))
         (else          (car (cdr (cdr (cdr (cdr (cdr (cdr delay))))))))
         (projected-ass (locus:project locus ass))
         (then-idiom    (compile then projected-ass marker))
         (then-locus    (locus:add (idiom-locus then-idiom) var (idiom-type then-idiom)))
         (then-expr     (finalize (idiom-expr then-idiom) then-locus))
         (else-idiom    (compile else projected-ass marker))
         (else-locus    (locus:add (idiom-locus else-idiom) var (idiom-type else-idiom)))
         (else-expr     (finalize (idiom-expr else-idiom) else-locus)))
    (list 'if compiled-pred then-locus then-expr else-locus else-expr)))